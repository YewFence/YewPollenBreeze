# This hook was automatically generated by push-backup
# DO NOT EDIT THIS SECTION MANUALLY
# To uninstall: run 'push-backup hook uninstall'

remote="$1"
url="$2"

# Only trigger when pushing to 'origin'
if [ "$remote" != "origin" ]; then
    exit 0
fi

# Read refs from stdin to determine what's being pushed
refs_to_push=""
while read local_ref local_oid remote_ref remote_oid; do
    # Skip deletions (local_oid is zero)
    zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
    if [ "$local_oid" = "$zero" ]; then
        continue
    fi

    # Extract branch/tag name from ref
    ref_name="${local_ref#refs/heads/}"
    ref_name="${ref_name#refs/tags/}"

    if [ -z "$refs_to_push" ]; then
        refs_to_push="$ref_name"
    else
        refs_to_push="$refs_to_push $ref_name"
    fi
done

# If no refs to push, exit early
if [ -z "$refs_to_push" ]; then
    exit 0
fi

# Find push-backup executable
PUSH_BACKUP_CMD=""
if command -v push-backup >/dev/null 2>&1; then
    PUSH_BACKUP_CMD="push-backup"
elif [ -n "$(which push-backup 2>/dev/null)" ]; then
    PUSH_BACKUP_CMD="$(which push-backup)"
fi

if [ -z "$PUSH_BACKUP_CMD" ]; then
    echo "[push-backup] Command not found in PATH, skipping automatic sync"
    exit 0
fi

# Allow user to skip hook via environment variable
if [ "$PUSH_BACKUP_SKIP_HOOK" = "1" ]; then
    echo "[push-backup] Hook disabled by PUSH_BACKUP_SKIP_HOOK"
    exit 0
fi

# Execute push-backup push
echo "[push-backup] Syncing to all configured remotes..."
"$PUSH_BACKUP_CMD" push --skip-check
exit_code=$?

if [ $exit_code -ne 0 ]; then
    echo "[push-backup] Sync failed (exit code: $exit_code)"
    echo "   Your push to origin will still complete."
    echo "   You can manually sync with: push-backup push"
fi

# Always succeed to not block the origin push
exit 0
